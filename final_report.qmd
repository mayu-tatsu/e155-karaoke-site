---
title: "Final Report"

tbl-cap-location: bottom
---

## Project Overview
This E155 final project sought to create a karaoke machine. 
The design allows users to choose a song to sing, displaying lyrics and playing the song as a guide via speaker, and ultimately compares the user’s singing to the expected frequencies, displaying both a letter grade and a percent error (between received and expected frequencies) after a song finishes.
The main input is a MEMS digital microphone, which goes through digital signal processing and FFT to pick up the correct frequencies at which people speak into the microphone.
The LCD screen functions as the principal user interface, directing users to choose songs, displaying lyrics, and presenting grades. 


## Project Specifications
* Design allows the user to choose a song through external hardware
* Design detects input frequencies between 300 to 2000 Hz
* Design scores the user’s singing by comparing detected and expected notes
* Design plays back the expected song through a speaker as reference
* Design utilizes a pitch and delay media format (as seen in Lab 4)
* Displays properly-timed lyrics on an LCD screen
* LCD display does not flicker


## Bill of Materials
| **Part Name**                         | **Part Number**                                                                                   | **Quantity** | **Price**                                                   | **Vendor**                                                  |
|:-------------------------------------:|:-------------------------------------------------------------------------------------------------:|:------------:|:-----------------------------------------------------------:|:-----------------------------------------------------------:|
| Adafruit PDM MEMS Microphone Breakout | [MP34DT01-M](https://www.st.com/en/audio-ics/mp34dt01-m.html)                                     | 1            | $11.23 *($4.95 part, $6.28 shipping + tax)*                 | [Adafruit](https://www.adafruit.com/product/3492)           |
| Hosyond I2C 2004 LCD Module           | [HD44780U](https://dfimg.dfrobot.com/enshop/image/data/DFR0154/LCD2004%20hd44780%20Datasheet.pdf) | 1            | $26.32 *($16.99 part, $6.99 shipping, $2.34 estimated tax)* | [Amazon](https://www.amazon.com/gp/product/B0C1G9GBRZ?th=1) |
| **TOTAL**                             |                                                                                                   |              | $37.55                                                      |                                                             |
: Bill of materials {#tbl-bom}


## Design Details
The general, high-level overview of our project — with all of the protocols used explicitly outlined — can be viewed in [Figure 1](#fpga-design-overview) below:

![Design overview](images/final_overview_diagram.jpg){#fig-final-overview-diagram}

### New Non-Trivial Hardware
New hardware described with notes about the features to be implemented and how they go beyond the previous material covered in the course.

The two new, non-trivial pieces of hardware that are used in this project are the Adafruit PDM microphone and the Hoysond LCD module.

#### Adafruit PDM Microphone
The PDM microphone is a microphone that outputs a digital signal.

#### Hoysond LCD Module
The LCD used has four rows and 20 columns — or, in other words, 80 total spaces — with which to write characters of its user's choosing.
There are two options for sending it instructions: either over I2C or directly through its eight data pins themselves.
Either way, the module uses the sequences of high and low voltages detected in tandem with a look-up table, with each operation having its own lead-in op-code (such as the Set Address and Clear Display functions) and each character having its own unique sequence associated with it.
The latter can be viewed rather clearly in [Figure 2](#fig-lcd-look-up-table), as follows:

![LCD character options](images/lcd_look_up_table.png){#fig-lcd-look-up-table width=60%}

Note that if you decide to communicate with the LCD by sending bits to all of its pins in parallel, each transaction will have to be ended with a short pulse of the Enable (E) bit, so as to tell the module that its information has been completely updated.

However, regardless 

It is powered by 5 V, with 

### FPGA Design Overview
Our microphone is a MP34DT01-M, a MEMS digital microphone.
We drive this using a 1.536 MHz clock signal generated by the FPGA, and the microphone outputs a PDM, which is then fed into the FPGA.
The top module is karaoke_top.sv, as found in fpga/src.
The FPGA feeds the PDM signal through a pipeline of 3 digital audio filters: a CIC filter (cic.sv), Half-Band filter (hb.sv), and FIR filter (fir.sv).

These filters were used to create a decimation ratio of 96, downsampling the 1.536 MHz PDM output down to a 16 kHz output.
The CIC takes the brunt of the decimation with a 24 decimation ratio in 4 stages, converts the PDM to a PCM, and normalizes the output values between -1 to 1.
The Half-Band and FIR filters create a passband from 0 to 4000 Hz, with a stopband at around 8000 Hz.
Both filters have a decimation ratio of 2, and their coefficients were determined using matplotlib functions.

The three filters generate a 16-bit, 16 kHz PCM output, with a new sample indicated by a pulse.
These signals are fed into the SPI module (spi.sv), which generates a CS, SCK, and SDO, acting as the controller in this case.
All relevant testbenches are found in "fpga/testbench" and the ModelSim project is found in "fpga/work" in our [GitHub repository](https://github.com/mayu-tatsu/e155-karaoke) (as also mentioned below).
The MCU then receives these values, acting as the peripheral, and accumulates them using the SPI peripheral, paired with the DMA peripheral.

Some difficulties we encountered:
* Finding the correct filter pipeline design and the coefficients
* Minimizing resource usage
* Figuring out new SPI configuration and implementing it
* Synthesizing and flashing the executable

### MCU Design Overview
Our MCU serves as the primary driver for everything in this project that isn't the microphone.



As for the MCU, one of the biggest problems was getting the LCD to consistently display the desired letters. More specifically, although the original plan was to use I2C to communicate between the two devices, it was discovered that there was a bit-expander attached to the bottom of the LCD that we had to go through first in order to actually write to our peripheral.  However, because the data sheet for such a chip was so vague and therefore hard to understand, we decided to simply bypass it and send information to the data pins in parallel, instead.  In total, there are eight data pins, as well as Read Select, Read/Write, and Enable pins.  Thus, with the GPIO pins that were already being used for SPI, there were just barely enough pins on the breakout board (that we were actually able to use, at least) for our intended path forward.

Unfortunately, there was still one key issue remaining: When we did this, some of the pins would display voltages of 1.5 V, as opposed to the ~3.3 V we expected.  Because the characters being written on the LCD (along with the addresses being written to) are all completely dependent on the voltage levels they receive—with different high and low voltage patterns corresponding to different characters—this was obviously not good.  More specifically, the minimum threshold for a voltage to be considered high by the LCD is 2.2 V, whereas the maximum threshold for a voltage to be considered low is 0.6 V; seeing as some pins had voltages floating between these two values, the LCD would randomly pick one to count it as and output the wrong thing accordingly.  Ultimately, we found out that the root cause of this was the existence of two 0 ohm resistors connecting some of the MCU GPIO pins together.  Thankfully, we were able to desolder these and subsequently use all of the pins as we initially intended.


## Technical Documentation
The source code for this project can be found in the associated [GitHub repository](https://github.com/mayu-tatsu/e155-karaoke).

### Block Diagram
![Block diagram](images/final_block_diagram.png){#fig-final-block-diagram}

The block diagram in [Figure 2](#fig-final-block-diagram) depicts the general architecture implied by the SystemVerilog code.

### Schematic
![Schematic](images/final_schematic.png){#fig-final-schematic}

[Figure 3](#fig-final-schematic) above depicts 

Overall, the microphone and FPGA interfacing was done in accordance with the [MP34DT01-M datasheet](https://github.com/mayu-tatsu/e155-karaoke-site/blob/main/files/mp34dt01-m.pdf).
The most prominent feature of note is the tying of the LR port to ground, as that configures a DOUT signal pattern of valid data when the CLK signal is low and high impedance when CLK is high.

### Flowchart {#sec-flowchart}
![Flowchart](){#fig-final-flowchart}

The [Figure 4](#fig-final-flowchart) flowchart provides a detailed overview of the microcontroller's most significant routines.


## Verification
Various means of verification were used to ensure the project's accuracy, including the following simulation waveforms and oscilloscope traces, as well as actual experimentation with the hardware itself.

### Testbench Simulation {#sec-testbench-simulation}
![CIC filter testbench](images/midpoint_cic_tb_waves.png){#fig-cic-tb}

![Halfband filter testbench](images/midpoint_hb_tb_waves.png){#fig-hb-tb}

![FIR filter testbench](images/midpoint_fir_tb_waves.png){#fig-fir-tb}

![Top Level testbench](images/midpoint_top_tb_waves.png){#fig-top-tb}

### Oscilloscope Traces
![LCD Logic Analyzer traces](images/lcd_logic_analyzer.png){#fig-lcd-logic-analyzer}


## Results
Results: What are the main results of your project.
Results section clearly and quantitatively outlines the key performance aspects of the design with commentary to explain the design decisions.

::: {#fig-video}
{{< video https://youtu.be/vw2rmU5o_nw?si=B0km_b63cXBgvwma >}}

Demo video
:::

![Final build](images/final_build.jpg){#fig-final-build}

![Team on Demo Day](images/demo_day_team.jpg){#fig-demo-day-team}

## References
References: Citation (and hyperlinks where relevant) to any outside resources that were referenced in the design of the project.
References are formatted with a clean and consistent format.


## Acknowledgements
We would like to thank the entire MicroPs teaching team for their help in getting this project off of the ground this semester, especially Kavi Dey ('26) and Prof. Spencer.
We really appreciate you!