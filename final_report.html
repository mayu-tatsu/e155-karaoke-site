<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Report – E155 Karaoke Final Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">E155 Karaoke Final Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./final_report.html" aria-current="page"> 
<span class="menu-text">Final Report</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#project-overview" id="toc-project-overview" class="nav-link active" data-scroll-target="#project-overview">Project Overview</a></li>
  <li><a href="#project-specifications" id="toc-project-specifications" class="nav-link" data-scroll-target="#project-specifications">Project Specifications</a></li>
  <li><a href="#bill-of-materials" id="toc-bill-of-materials" class="nav-link" data-scroll-target="#bill-of-materials">Bill of Materials</a></li>
  <li><a href="#design-details" id="toc-design-details" class="nav-link" data-scroll-target="#design-details">Design Details</a>
  <ul class="collapse">
  <li><a href="#sec-new-non-trivial-hardware" id="toc-sec-new-non-trivial-hardware" class="nav-link" data-scroll-target="#sec-new-non-trivial-hardware">New Non-Trivial Hardware</a></li>
  <li><a href="#fpga-design-overview" id="toc-fpga-design-overview" class="nav-link" data-scroll-target="#fpga-design-overview">FPGA Design Overview</a></li>
  <li><a href="#mcu-design-overview" id="toc-mcu-design-overview" class="nav-link" data-scroll-target="#mcu-design-overview">MCU Design Overview</a></li>
  </ul></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a>
  <ul class="collapse">
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#sec-schematic" id="toc-sec-schematic" class="nav-link" data-scroll-target="#sec-schematic">Schematic</a></li>
  <li><a href="#sec-flowchart" id="toc-sec-flowchart" class="nav-link" data-scroll-target="#sec-flowchart">Flowchart</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#sec-testbench-simulation" id="toc-sec-testbench-simulation" class="nav-link" data-scroll-target="#sec-testbench-simulation">Testbench Simulation</a></li>
  <li><a href="#oscilloscope-traces" id="toc-oscilloscope-traces" class="nav-link" data-scroll-target="#oscilloscope-traces">Oscilloscope Traces</a></li>
  <li><a href="#documentation" id="toc-documentation" class="nav-link" data-scroll-target="#documentation">Documentation</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="project-overview" class="level2">
<h2 class="anchored" data-anchor-id="project-overview">Project Overview</h2>
<p>This E155 final project sought to create a karaoke machine. The design allows users to choose a song to sing, displaying lyrics and playing the song as a guide via speaker, and ultimately compares the user’s singing to the expected frequencies, displaying both a letter grade and a percent error (between received and expected frequencies) after a song finishes. The main input is a MEMS digital microphone, which goes through digital signal processing and FFT to pick up the correct frequencies at which people speak into the microphone. The LCD screen functions as the principal user interface, directing users to choose songs, displaying lyrics, and presenting grades.</p>
</section>
<section id="project-specifications" class="level2">
<h2 class="anchored" data-anchor-id="project-specifications">Project Specifications</h2>
<ul>
<li>Design allows the user to choose a song through external hardware</li>
<li>Design detects input frequencies between 300 to 2000 Hz</li>
<li>Design scores the user’s singing by comparing detected and expected notes</li>
<li>Design plays back the expected song through a speaker as reference</li>
<li>Design utilizes a pitch and delay media format (as seen in Lab 4)</li>
<li>Displays properly-timed lyrics on an LCD screen</li>
<li>LCD display does not flicker</li>
</ul>
</section>
<section id="bill-of-materials" class="level2">
<h2 class="anchored" data-anchor-id="bill-of-materials">Bill of Materials</h2>
<div id="tbl-bom" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<div aria-describedby="tbl-bom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Part Name</strong></th>
<th style="text-align: center;"><strong>Part Number</strong></th>
<th style="text-align: center;"><strong>Quantity</strong></th>
<th style="text-align: center;"><strong>Price</strong></th>
<th style="text-align: center;"><strong>Vendor</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Adafruit PDM MEMS Microphone Breakout</td>
<td style="text-align: center;"><a href="https://www.st.com/en/audio-ics/mp34dt01-m.html">MP34DT01-M</a></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$11.23 <em>($4.95 part, $6.28 shipping + tax)</em></td>
<td style="text-align: center;"><a href="https://www.adafruit.com/product/3492">Adafruit</a></td>
</tr>
<tr class="even">
<td style="text-align: center;">Hosyond I2C 2004 LCD Module</td>
<td style="text-align: center;"><a href="https://dfimg.dfrobot.com/enshop/image/data/DFR0154/LCD2004%20hd44780%20Datasheet.pdf">HD44780U</a></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$26.32 <em>($16.99 part, $6.99 shipping, $2.34 estimated tax)</em></td>
<td style="text-align: center;"><a href="https://www.amazon.com/gp/product/B0C1G9GBRZ?th=1">Amazon</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>TOTAL</strong></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$37.55</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-tbl" id="tbl-bom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Bill of materials
</figcaption>
</figure>
</div>
</section>
<section id="design-details" class="level2">
<h2 class="anchored" data-anchor-id="design-details">Design Details</h2>
<p>The general, high-level overview of our project — with all of the protocols used explicitly outlined — can be viewed in <a href="#fpga-design-overview">Figure 1</a> below:</p>
<div id="fig-final-overview-diagram" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-final-overview-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/final_overview_diagram.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-final-overview-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Design overview
</figcaption>
</figure>
</div>
<section id="sec-new-non-trivial-hardware" class="level3">
<h3 class="anchored" data-anchor-id="sec-new-non-trivial-hardware">New Non-Trivial Hardware</h3>
<p>The two new, non-trivial pieces of hardware that are used in this project are the Adafruit PDM microphone and the Hoysond LCD module.</p>
<section id="adafruit-pdm-microphone" class="level4">
<h4 class="anchored" data-anchor-id="adafruit-pdm-microphone">Adafruit PDM Microphone</h4>
<p>We used a MP34DT01-M, a MEMS digital microphone. It outputs data in Pulse-Density Modulation (PDM) format, which is a format of representing an analog signal in a single bit, with the density of 1’s and 0’s reflecting the amplitude of the signal.</p>
<p>This microphone itself took 4 inputs: a 3.3V power supply, a ground, a L/R channel selector for simplified stereo applications, and a synchronization input clock. The input clock was valid between frequencies of 3.25 to 1 MHz, which meant we were able to select a frequency and drive it from the FPGA. We chose to ground L/R out of default. The output was the Dout pin, and could be read by an FPGA pin in PDM format. The clock and Dout were connected directly to the FPGA board to minimize lag and voltage drop.</p>
<p>Within E155, there has been no usage of this PDM format. The closest data format or acquisition method we had gone over was quadrature encoders, which we used in Lab 5. They were able to represent analog motion in two 1-bit digital signals, but PDM is a distinct method of representing analog waves in a single bit, which is beyond the previous material of this course.</p>
</section>
<section id="hoysond-lcd-module" class="level4">
<h4 class="anchored" data-anchor-id="hoysond-lcd-module">Hoysond LCD Module</h4>
<p>The LCD used seems to comprise the HD44780 Hitachi controller chip, as well as a PCF8574A bit-expander for I2C interfacing. The screen itself has four rows and 20 columns — or, in other words, 80 total spaces — with which to write characters of its user’s choosing. It needs 5 V of power to display characters properly, with the ability to adjust both its backlight brightness and contrast. There are two options for sending it instructions: either over I2C or directly through its 11-pin parallel interface, including:</p>
<ul>
<li>1 Enable bit (<code>E</code>)</li>
<li>1 Register Select bit (<code>RS</code>)</li>
<li>1 Read/Write bit (<code>RW</code>)</li>
<li>8 data pins (<code>D0</code> - <code>D7</code>)</li>
</ul>
<p>More specifics about these pins and their respective functionalities can be found in the <a href="https://www.handsontec.com/dataspecs/I2C_2004_LCD.pdf">datasheet</a> for the LCD’s Hitachi controller, specifically. Regardless, for both methods of communication, the module uses the sequences of high and low voltages detected in tandem with a look-up table, with each operation having its own lead-in op-code (such as the Set Address and Clear Display functions) and each character having its own unique sequence associated with it. The latter can be viewed rather clearly in <a href="#fig-lcd-look-up-table">Figure 2</a>, as follows:</p>
<div id="fig-lcd-look-up-table" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lcd-look-up-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/lcd_look_up_table.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lcd-look-up-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: LCD character options
</figcaption>
</figure>
</div>
<p>Note that if you decide to communicate with the LCD by sending bits to all of its pins in parallel, each transaction will have to be ended with a short pulse of the Enable (<code>E</code>) bit, so as to tell the module that its information has been completely updated.</p>
<p>Moreover, the LCD requires a specifically-timed initialization sequence in order to fully function. This is outlined in <a href="#fig-lcd-initialization">Figure 3</a>.</p>
<div id="fig-lcd-initialization" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lcd-initialization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/lcd_initialization_sequence.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lcd-initialization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: LCD initialization
</figcaption>
</figure>
</div>
<p>Ultimately, the features implemented with this hardware go above and beyond the previous material covered in class, as they require the configuration of an external display. More specifically, we had to learn about the different communication protocols that an LCD can use, and compare the pros and cons of both. Eventually, we came to the conclusion that using a parallel interface would be best because 1) when there are pins to spare for it, it’s the fastest, and 2) the <a href="https://www.nxp.com/docs/en/data-sheet/PCF8574_PCF8574A.pdf">datasheet</a> for the PCF8574A bit-expander is vague and thus, it is extremely hard to parse how to interact with it when using I2C; in the interest of not getting hung-up over something that could be easily avoided, we decided to bypass it entirely. (See the <a href="#sec-schematic">Schematic</a> section below for more details on some bugs that we needed to address when doing this.)</p>
</section>
</section>
<section id="fpga-design-overview" class="level3">
<h3 class="anchored" data-anchor-id="fpga-design-overview">FPGA Design Overview</h3>
<p>The FPGA is in control of the microphone, processing its data, and sending that data to the MCU. Our microphone is a MP34DT01-M, a MEMS digital microphone. We drive this using a 1.536 MHz clock signal generated by the FPGA, and the microphone outputs data in Pulse-Density Modulation (PDM) format, which is then fed back into the FPGA. PDM is a format of representing an analog signal in a single bit, with the density of 1’s and 0’s reflecting the amplitude of the <a href="#fig-pdm-vs-analog-signal">Figure 4</a> signal.</p>
<div id="fig-pdm-vs-analog-signal" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pdm-vs-analog-signal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/pdm_vs_analog_signal.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pdm-vs-analog-signal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: PDM vs.&nbsp;Analog signals
</figcaption>
</figure>
</div>
<p>The top module is karaoke_top.sv, as found in the <a href="https://github.com/mayu-tatsu/e155-karaoke">GitHub</a>’s <code>fpga/src</code>. The FPGA feeds the PDM signal through a pipeline of 3 digital audio filters: a CIC filter / <code>cic.sv</code>, half-band filter / <code>hb.sv</code>, and FIR filter / <code>fir.sv</code>.</p>
<p>These three filters were used to create a decimation ratio of 96, downsampling the 1.536 MHz PDM output down to a 16 kHz output. The CIC takes the brunt of the decimation with a 24 decimation ratio in 4 stages, converts the PDM to a PCM, and normalizes the output values between -1 to 1. The half-band and FIR filters create a passband from 0 to 4000 Hz, with a stopband at around 8000 Hz. Both filters have a decimation ratio of 2, and their coefficients were determined using matplotlib functions.</p>
<p>The three filters generate a 16-bit, 16 kHz PCM output, with a new sample indicated by a pulse. These signals are fed into the SPI module / <code>spi.sv</code>, which generates a <code>CS</code>, <code>SCK</code>, and <code>SDO</code>, acting as the controller/master in this case. All relevant testbenches are found in <code>fpga/testbench</code> and the ModelSim project is found in <code>fpga/work</code>. The MCU then receives these values, acting as the peripheral/slave, and accumulates them using the SPI peripheral, paired with the DMA peripheral.</p>
<p>Some difficulties we encountered:</p>
<ul>
<li>Finding the correct filter pipeline design and the coefficients for the half-band and FIR</li>
<li>Minimizing resource usage</li>
<li>Figuring out new SPI configuration and implementing it</li>
<li>Synthesizing and flashing the executable</li>
</ul>
<p>Initially, we were naively hoping to create a decimation ratio of 144, bringing a PDM input rate of 2.304 MHz down to 16 kHz. This was due to a misunderstanding of half-band filters and the resources we could fit onto the board. Half-band filters are optimized FIR filters that require only half the number of taps, and therefore multiplications, but also can only decimate (or interpolate) at a rate of 2 every filter. We had assumed that half-bands filters would be able to handle 3x and 4x decimation (which, no, is not possible) during the project proposal stage. Once we read up more on half-bands, we decided to move to a 1.536 MHz to decimate it down to 16 kHz using a decimation ratio of 96. We determined that, for our purposes, the CIC filter would be able to handle a 24 decimation ratio without much change in ripple or attenuation via this <a href="">Figure 5</a> chart:</p>
<div id="fig-decimation-chart" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decimation-chart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/decimation_chart.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-decimation-chart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: CIC decimation chart
</figcaption>
</figure>
</div>
<p>Since we wanted to make sure that the FIR would be able to handle everything in 16 taps to keep resource levels low, we decided to use two half-bands and keep the FIR only to minimize passband ripple and maximize stopband attenuation. However, when we loaded this onto the FPGA, there were not enough LUTs to accommodate this design. As a result, we settled on a finalized design of a 24-decimation ratio, 4-stage CIC filter, a half-band filter, and a 2x decimating and correcting final FIR filter.</p>
<p>When it came to determining the coefficients, we started off trying to use some MATLAB code, but switched to Python with its easier <code>remez()</code> function. The code for this can be found here. When it came to implementing these filters in Verilog, we mentioned that it was difficult due to resource constraints. There was some trial-and-error involved, trying to get it down from 170+% resource usage down to our final 94% LUT4 usage. Our biggest issue was the multiplications required. The FPGA only has 8 DSP blocks, and all of those were devoted to the half-band multiplications. Which meant that the CIC, FIR, and the rest of the half-band additions all had to fit their calculations in the LUTs. The CIC was generally resource-optimized already due to its perk requiring only adders and delays by design. The FIR and half-band took some tweaking. We implemented pipelining in both filters to keep the critical path short and allow the synthesis tool to map arithmetic into smaller, slower LUT-based adders rather than huge blocks dedicated to multiplication. Then, we replaced all true multipliers in the FIR with hardcoded shift-add coefficient implementations, which finally pushed down our LUT usage below 100%.</p>
<p>We also hit some snags while implementing the SPI. We were using some code based on Lab 7, which assumes a MCU-master, FPGA-slave configuration. However, it quickly came to be that our FPGA should be the master in our context, and as we switched those things around, as a result, we needed a new chip select (<code>CS</code>) signal, and switched around some pins. However, there was some confusion about which board should generate the <code>CS</code> signal between us partners, and the silkscreen and boards were generally designed around the assumption that the MCU would always be the master. That, and some two sets of pins coming out of the FPGA both labelled <code>SCK</code>/<code>CS</code>/<code>MISO-CIPO</code> took a day or two to figure out.</p>
<p>Finally, once we got almost everything working regarding the MCU peripherals and the FPGA SPI module, we had some issues where, even in ambient noise, the microphone, filters, and FFTs combined would produce outputs ranging from 100 to 6000 Hz, jumping values multiple times in a second. We knew from verification and testing that all of these mechanisms should work in isolation, so we weren’t sure where the mix-up was coming from. In a last-ditch test to see if the ambient noise was too much (which it wasn’t), we left the lab to go to a quieter room. It turns out that synthesizing and loading the executable from Quinn’s personal computer through OpenFPGALoader fixed completely all of our issues despite using the same exact code and project setup (same <code>.rdf</code> files for Lattice, same Lattice version). There may be some timing constraints that we never specified that could be causing these mapping inconsistencies, but overall, we are still unsure exactly why this is. However, as a result, the microphone and FFT are now able to accurately detect and output frequencies.</p>
</section>
<section id="mcu-design-overview" class="level3">
<h3 class="anchored" data-anchor-id="mcu-design-overview">MCU Design Overview</h3>
<p>In short, our MCU serves as the primary driver for everything in this project that isn’t our microphone. The most significant components of its design — comprising both peripheral configurations and general functionalities — are listed and expounded upon as follows (note that a more visual representation of these routines can be found in a later <a href="#sec-flowchart">Flowchart</a> section):</p>
<section id="spi" class="level4">
<h4 class="anchored" data-anchor-id="spi">SPI</h4>
<p>First and foremost, SPI Receive-Only mode is set up such that the FPGA acts as the controller in every transaction, while the MCU acts exclusively as the peripheral. Although we initially used the SPI initialization function provided in <a href="https://qmiyamoto.github.io/E155-Portfolio/labs/lab7/lab7.html">Lab 7</a> as starter code, we quickly realized that this wouldn’t work, due to the nature of what we were trying to accomplish: a one-sided intake of information that the FPGA initiates, as opposed to two-way communication started off by the MCU. Taking advantage of the built-in connections between the FPGA and MCU pins on our PCB, we eventually set up the latter to continuously receive <code>SCK</code>, <code>CS</code>, and <code>SDO</code> signals as input from the former. It then stores the SDO data — our raw audio samples — in its data register, which we configure to be accessible by DMA.</p>
</section>
<section id="dma" class="level4">
<h4 class="anchored" data-anchor-id="dma">DMA</h4>
<p>The DMA peripheral, in essence, negates the need to use the <code>spiSendReceive()</code> function every time we want to read the data our MCU is receiving. Instead, it offers the option of automatically storing the contents of the SPI data register into a buffer array, so that the CPU is free to focus on running other, more intensive tasks. Notably, we configure our DMA to run in circular mode, so that we don’t need to manually disable and reenable the peripheral every time we want to update the array.</p>
<p>Additionally, we have an interrupt that triggers on the DMA’s transfer-complete flag, waits until FFT calculations are complete, and copies the DMA buffer’s contents into a second, FFT-accessible array. This is done so that there is always one buffer holding the raw audio data and one buffer being mathematically processed, such that we don’t lose any important information in the case of the latter process being delayed.</p>
</section>
<section id="audio" class="level4">
<h4 class="anchored" data-anchor-id="audio">Audio</h4>
<p>For the actual song-playing aspect of the project, we simply reused the code we wrote previously in <a href="https://qmiyamoto.github.io/E155-Portfolio/labs/lab4/lab4.html">Lab 4</a> to play each song’s main singing melody. In fact, Lab 4 is where part of the original idea to do this stems from — we both thoroughly enjoyed the assignment and were interested in pursuing more ventures into the realm of audio. Overall, we mainly took the following: the PWM-generation code (generalized to work with any timer this time) and the specific setup for song arrays, {frequency (Hz), duration (ms)}. However, to achieve cleaner code this time, we decided to store all relevant song information in a header file instead of our main function. At the moment, we have two songs available to be played: Mr.&nbsp;Brightside and Golden.</p>
<p>In the future, if we are to work on this project once more, we think it would be nice to have multiple tunes playing at once, so that we can realize the full brilliance of our songs and their harmonies. Moreover, it would be nice if there were a more convenient, less labor-intensive way to create each song array. This would allow us to have more song options available.</p>
<p>Credit goes to <a href="https://www.linkedin.com/in/cole-plepel/">Cole Plepel</a> for doing the actual transcribing of our desired notes.</p>
</section>
<section id="timing" class="level4">
<h4 class="anchored" data-anchor-id="timing">Timing</h4>
<p>To ensure that a given song’s lyrics show up at the same time as the relevant beats, we first made an array that contained strings we could pass into the <code>display_message()</code> function (elaborated on below). Then, we created a timing array; this is the exact same length as the notes array, populated with zeros for notes we <em>don’t</em> want to change lyrics on and the index of the desired lyric on the notes we <em>do</em> want to change lyrics on. Whenever a nonzero timing array item is detected, it goes to the index of the lyrics array indicated and prints the words accordingly. While this was rather tedious to write and check by hand, it provides a fool-proof way of showing the correct line at the correct time always.</p>
</section>
<section id="fft" class="level4">
<h4 class="anchored" data-anchor-id="fft">FFT</h4>
<p>In order to understand what each audio sample’s dominant frequency is — and therefore, what note someone is singing — an FFT needs to be applied to the raw values. Thankfully, with the help of a <a href="https://youtu.be/Z3_YsXXgWzw?si=PaWCxyRoxPfmdG3T">tutorial</a>, this was extremely easy to do. In short, we have downloaded the <a href="https://github.com/STMicroelectronics/cmsis-core/tree/10c319e2ed1a53a382f43a99eaa2b7b03d5b3489/DSP/Source">ARM math library</a> and are now making use of its built-in functions. First, we apply Z-score normalization to the raw data, then a Hanning window, in order to maintain amplitude measurement accuracy while simultaneously reducing spectral leakage. Next, we pass this pre-processed signal into the actual FFT function, and take the magnitude of its resulting frequencies. Finally, we pick out and return the largest one.</p>
</section>
<section id="grading" class="level4">
<h4 class="anchored" data-anchor-id="grading">Grading</h4>
<p>Although our song-storing scheme is noted to be quite cumbersome above, it also allows for extremely easy grading. More specifically, we set a flag every time we’re done playing a note, which then triggers an interrupt. Inside the interrupt, we call our FFT function and compare the output frequency of that to the note we just played (and are therefore expecting to also hear from the user) at that point in time. We then keep a running total of the error calculated from this comparison, as well as a running total of the times this interrupt has been triggered.</p>
<p>At the very end of a song’s run, we proceed to call <code>singing_grader()</code>, which calculates the user’s average error over the entire song by dividing the aforementioned running total of frequency error over the number of interrupt triggers, then multiplying the quotient by one hundred. Finally, we use the LCD to provide a letter grade based on — quite generously — a curve, as well as the percent error computed.</p>
</section>
<section id="lcd" class="level4">
<h4 class="anchored" data-anchor-id="lcd">LCD</h4>
<p>There are five significant functions for the LCD: <code>lcd_display_initialization()</code>, <code>lcd_display_write()</code>, <code>character_converter()</code>, <code>lcd_display_reset()</code>, and <code>display_message()</code>.</p>
<p>The first, <code>lcd_display_initialization()</code>, is rather self-explanatory. As mentioned in the <a href="#sec-new-non-trivial-hardware">New, Non-Trivial Hardware</a> section above, there is a very specifically timed process that the LCD needs to go through in order to properly display anything. While it was a little hard to find the relevant page in the datasheet at first, we were eventually able to accomplish this easily. It also turns off the cursor and sets the starting address of the LCD’s Write to the first row and first column.</p>
<p><code>lcd_display_write()</code> is also a simple function. It receives a nine-bit integer input and shifts each bit into the appropriate pin, such that the LCD is given some high-low sequence that it recognizes. <code>E</code> is then pulsed to push the updated information fully.</p>
<p>Meanwhile, <code>character_converter()</code> consists entirely of one giant look-up table that matches the one depicted in <a href="#fig-lcd-look-up-table">Figure 2</a> above. It takes a string as input and checks whether or not said string matches a known character. If that is indeed the case, it outputs the corresponding number sequence that the LCD will actually understand.</p>
<p>Furthermore, <code>lcd_display_reset()</code> turns the display off, clears the screen, and turns it back on again.</p>
<p>Finally, <code>display_message()</code> combines all of the above to take in longer strings — such as lyrics — and get the LCD screen to output them accordingly. Note that due to the physical restrictions of the display, with there only being space for 80 characters at a time, writing more than that alloted amount will lead to wrap-around and incorrect messages; also, inputs have to be formatted taking into account the fact that the LCD writes to the first row first, then the third, second, and fourth, in that order. We initially struggled a little with stitching everything together, due to not really understanding pointers and addresses as well as we should have, but after addressing our mistake of passing a pointer into the function instead of a regular string like it was expecting, everything turned out fine.</p>
</section>
<section id="song-selection" class="level4">
<h4 class="anchored" data-anchor-id="song-selection">Song Selection</h4>
<p>Songs are chosen when you flip the associated switch to enable them. The LCD tells you which switch is which.</p>
</section>
</section>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h2>
<p>The source code for this project can be found in the associated <a href="https://github.com/mayu-tatsu/e155-karaoke">GitHub repository</a>.</p>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<div id="fig-final-block-diagram" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-final-block-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/final_block_diagram.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-final-block-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Block diagram
</figcaption>
</figure>
</div>
<p>The block diagram in <a href="#fig-final-block-diagram">Figure 6</a> depicts the general architecture implied by the SystemVerilog code.</p>
</section>
<section id="sec-schematic" class="level3">
<h3 class="anchored" data-anchor-id="sec-schematic">Schematic</h3>
<div id="fig-final-schematic" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-final-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/final_schematic.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-final-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Schematic
</figcaption>
</figure>
</div>
<p><a href="#fig-final-schematic">Figure 7</a> above depicts the physical connections between all of the project’s necessary electronic components. This includes the PDM microphone, LCD screen, speaker, audio amplifier, switches, FPGA, and MCU.</p>
<p>Note that the microphone and FPGA interfacing is done in accordance with the <a href="https://github.com/mayu-tatsu/e155-karaoke-site/blob/main/files/mp34dt01-m.pdf">MP34DT01-M datasheet</a>. The most prominent feature of note is the tying of the <code>LR</code> port to ground, as that configures a <code>pdm_data</code> signal pattern of valid data when the CLK signal is low and high impedance when CLK is high.</p>
<p>Additionally, the MCU has direct, one-to-one pin connections with the LCD, with the exceptions being <code>RW</code> and <code>V0</code>. <code>RW</code> is tied directly to ground because we are only performing Write operations with the LCD and never Read ones, so the bit never needs to be set; by just wiring it to ground instead of sending a zero to the pin every time, this allows us to free up MCU ports that we can use for other, more important connections. Meanwhile, <code>V0</code> is wired to the output of a 10 kΩ potentiometer, so that the contrast between the backlight and the characters being displayed can be controlled.</p>
<p>Furthermore, the MCU-audio-amplifier-speaker circuit shown at the very bottom is yet another component taken from <a href="https://qmiyamoto.github.io/E155-Portfolio/labs/lab4/lab4.html">Lab 4</a>, affording the users the ability to modify the speaker’s volume.</p>
<p>However, most notably of all, is the fact that MCU pins PA5 and PB7 are no longer connected, nor are PA6 and PB6. Previously, while it is not noted on the PCB schematic we are given for this class — or anywhere easily found in official STM32 documentation, for that matter — those two pairs of pins share respective connections via two surface-mounted 0 Ω resistors. This was rather frustrating to discover, as we were struggling with the LCD showing randomly inserted, completely incorrect characters for the longest time. As it turns out, because the LCD (without using I2C to communicate) depends entirely on the accuracy of analog signals, it was confused when it received voltages of 1.5 from those four pins, specifically — half of the 3.3 V signal it <em>should</em> have been getting. Seeing as 1.5 V is below the minimum threshold of 2.2 V to count as a high signal and above the maximum threshold of 0.6 V to count as a low signal, the LCD simply chose at random every time it encountered this problem. Thus, while difficult to portray in the above schematic, the removal of these resistors is perhaps the single-most important aspect of the circuit design to our team.</p>
</section>
<section id="sec-flowchart" class="level3">
<h3 class="anchored" data-anchor-id="sec-flowchart">Flowchart</h3>
<div id="fig-final-flowchart" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-final-flowchart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/final_flowchart.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-final-flowchart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Flowchart
</figcaption>
</figure>
</div>
<p>The <a href="#fig-final-flowchart">Figure 8</a> flowchart provides a detailed overview of the microcontroller’s most significant routines.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="sec-testbench-simulation" class="level3">
<h3 class="anchored" data-anchor-id="sec-testbench-simulation">Testbench Simulation</h3>
<div id="fig-cic-tb" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cic-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/midpoint_cic_tb_waves.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cic-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: CIC filter testbench
</figcaption>
</figure>
</div>
<p>[TO-DO!]</p>
<div id="fig-hb-tb" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hb-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/midpoint_hb_tb_waves.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hb-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Halfband filter testbench
</figcaption>
</figure>
</div>
<p>[TO-DO!]</p>
<div id="fig-fir-tb" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fir-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/midpoint_fir_tb_waves.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fir-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: FIR filter testbench
</figcaption>
</figure>
</div>
<p>[TO-DO!]</p>
<div id="fig-top-tb" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-top-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/midpoint_top_tb_waves.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-top-tb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12: Top Level testbench
</figcaption>
</figure>
</div>
<p>[TO-DO!]</p>
</section>
<section id="oscilloscope-traces" class="level3">
<h3 class="anchored" data-anchor-id="oscilloscope-traces">Oscilloscope Traces</h3>
<div id="fig-lcd-logic-analyzer" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lcd-logic-analyzer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/lcd_logic_analyzer.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lcd-logic-analyzer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13: LCD Logic Analyzer traces
</figcaption>
</figure>
</div>
</section>
<section id="documentation" class="level3">
<h3 class="anchored" data-anchor-id="documentation">Documentation</h3>
<div id="fig-video" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-video-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/vw2rmU5o_nw?si=B0km_b63cXBgvwma" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-video-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;14: Demo video
</figcaption>
</figure>
</div>
<div id="fig-final-build" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-final-build-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/final_build.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-final-build-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;15: Final build
</figcaption>
</figure>
</div>
<div id="fig-demo-day-team" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-demo-day-team-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/demo_day_team.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-demo-day-team-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;16: Team on Demo Day
</figcaption>
</figure>
</div>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p><a href="https://hmc-e155.github.io/">E155</a>: Course website.</p>
<p><a href="https://hmc-e155.github.io/assets/doc/ds11451-stm32l432kc.pdf">STM32L432KC Datasheet</a>: STM32 MCU datasheet.</p>
<p><a href="https://hmc-e155.github.io/assets/doc/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32L432KC Reference Manual</a>: STM32 MCU reference manual.</p>
<p><a href="https://qmiyamoto.github.io/E155-Portfolio/">Quinn Miyamoto’s E155 Portfolio</a>: Team member Quinn Miyamoto’s portfolio of this course’s labs.</p>
<p><a href="https://jacksonphilion.github.io/final-project-portfolio/">Fix That Note! E155 Final Project Portfolio</a>: Past E155 portfolio for the Fix That Note! project, which involved telling a user what note their system was detecting.</p>
<p><a href="https://tomverbeure.github.io/2020/09/30/Moving-Average-and-CIC-Filters.html">An Intuitive Look at Moving Average and CIC Filters</a>: A series of blogs made by Tom Verbeure on designing a pipeline for audio decimation and filtering.</p>
<p><a href="https://www.mathworks.com/help/dsp/ug/fir-halfband-filter-design.html">FIR Halfband Filter Design</a>: A MATLAB guide to designing half-band filters, used in conjunction with the DSP-Related article below.</p>
<p><a href="https://www.dsprelated.com/showarticle/1113.php">Simplest Calculation of Half-band Filter Coefficients</a>: An online guide to designing half-band filter coefficients.</p>
<p><a href="https://github.com/jaycordaro/half-band-filter">jaycordaro/half-band-filter</a>: An implementation of a half-band FIR filter, from MATLAB to fixed point in SystemVerilog.</p>
<p><a href="https://cdn-learn.adafruit.com/assets/assets/000/049/977/original/MP34DT01-M.pdf">MEMS audio sensor omnidirectional digital microphone</a>: Datasheet for MP34DT01-M.</p>
<p><a href="https://controllerstech.com/interface-lcd-16x2-with-stm32-without-i2c/">Interface 16×2 LCD with STM32 (No I2C) — 4-bit Guide</a>: A guide to interfacing an LCD with an STM32 MCU with an 11-line parallel bus, instead of I2C.</p>
<p><a href="https://deepbluembedded.com/stm32-lcd-16x2-tutorial-library-alphanumeric-lcd-16x2-interfacing/">STM32 LCD 16×2 Library &amp; Example | LCD Display Interfacing</a>: A guide to initializing and writing to an LCD using an STM32 MCU.</p>
<p><a href="https://www.handsontec.com/dataspecs/I2C_2004_LCD.pdf">I2C Serial Interface 20x4 LCD Module</a>: Datasheet for the LCD’s HD44780 controller chip.</p>
<p><a href="https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/3477/MC21605A6W-FPTLW.pdf">MC21605A6W-FPTLW</a>: Alternative LCD datasheet.</p>
<p><a href="https://m0agx.eu/generating-signals-with-stm32l4-timer-dma-and-dac.html">Generating signals with STM32L4 timer, DMA and DAC</a>: A guide to interfacing DMA with SPI.</p>
<p><a href="https://youtu.be/Z3_YsXXgWzw?si=PaWCxyRoxPfmdG3T">Fast Fourier Transform using the ARM CMSIS Library within the STM32 MCUs</a>: A video tutorial on how to pick a dominant frequency out of a given signal on the STM32 MCU, using ARM math functions (including the FFT).</p>
<p><a href="https://thetechylife.com/how-do-you-normalize-a-signal/">Normalizing Signals for Enhanced Analysis and Interpretation</a>: A guide to normalizing signals as preparation for Fourier Transforms.</p>
<p><a href="https://github.com/STMicroelectronics/cmsis-core/tree/10c319e2ed1a53a382f43a99eaa2b7b03d5b3489/DSP/Source">STMicroelectronics/cmsis-core</a>: GitHub repository of all ARM math functions.</p>
</section>
<section id="acknowledgements" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>We would like to thank the entire MicroPs teaching team for their help in getting this project off of the ground this semester, especially <a href="https://www.linkedin.com/in/kavidey/">Kavi Dey</a> (’26) and Prof.&nbsp;Spencer. Additionally, special thanks goes out to <a href="https://www.linkedin.com/in/cole-plepel/">Cole Plepel</a> (’27) for transcribing our karaoke machine’s music. We really appreciate you!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mayu-tatsu\.github\.io\/e155-karaoke-site\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>